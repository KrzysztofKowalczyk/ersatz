<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ErsatzRequest.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ersatz</a> &gt; <a href="index.source.html" class="el_package">com.stehno.ersatz.impl</a> &gt; <span class="el_source">ErsatzRequest.groovy</span></div><h1>ErsatzRequest.groovy</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Christopher J. Stehno
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.stehno.ersatz.impl

import com.stehno.ersatz.ClientRequest
import com.stehno.ersatz.Cookie
import com.stehno.ersatz.CookieMatcher
import com.stehno.ersatz.HttpMethod
import com.stehno.ersatz.Request
import com.stehno.ersatz.Response
import com.stehno.ersatz.ResponseEncoders
import org.hamcrest.Matcher
import org.hamcrest.StringDescription

import java.util.function.Consumer

import static com.stehno.ersatz.HttpMethod.ANY
import static com.stehno.ersatz.HttpMethod.DELETE
import static com.stehno.ersatz.HttpMethod.GET
import static com.stehno.ersatz.HttpMethod.HEAD
import static com.stehno.ersatz.HttpMethod.OPTIONS
import static com.stehno.ersatz.HttpMethod.PATCH
import static com.stehno.ersatz.HttpMethod.POST
import static com.stehno.ersatz.HttpMethod.PUT
import static com.stehno.ersatz.HttpMethod.TRACE
import static com.stehno.ersatz.impl.Delegator.delegateTo
import static groovy.lang.Closure.DELEGATE_FIRST
import static org.hamcrest.Matchers.anything
import static org.hamcrest.Matchers.contains
import static org.hamcrest.Matchers.containsInAnyOrder
import static org.hamcrest.Matchers.equalTo
import static org.hamcrest.Matchers.equalToIgnoringCase
import static org.hamcrest.Matchers.hasItem
import static org.hamcrest.Matchers.isOneOf

/**
 * &lt;code&gt;Request&lt;/code&gt; implementation representing requests without body content.
 */
class ErsatzRequest implements Request {

<span class="fc" id="L54">    private final List&lt;RequestMatcher&gt; matchers = []</span>
<span class="fc" id="L55">    private final List&lt;Consumer&lt;ClientRequest&gt;&gt; listeners = []</span>
<span class="fc" id="L56">    private final List&lt;Response&gt; responses = []</span>
    private final ResponseEncoders globalEncoders
    private final boolean emptyResponse
<span class="fc" id="L59">    private Matcher&lt;?&gt; callVerifier = anything()</span>
    private int callCount

    /**
     * Creates a new request with the specified method, path matcher and optional empty response flag (defaults to false).
     *
     * @param meth the request method
     * @param pathMatcher the path matcher
     * @param noResponse whether or not this is a request with an empty response (defaults to false)
     */
    ErsatzRequest(
        final HttpMethod meth,
        final Matcher&lt;String&gt; pathMatcher, final ResponseEncoders globalEncoders, final boolean noResponse = false) {
<span class="fc bfc" id="L72" title="All 2 branches covered.">        matchers &lt;&lt; RequestMatcher.method(meth == ANY ? isOneOf(GET, HEAD, POST, PUT, DELETE, PATCH, OPTIONS, TRACE) : equalTo(meth))</span>
<span class="fc" id="L73">        matchers &lt;&lt; RequestMatcher.path(pathMatcher)</span>

<span class="fc" id="L75">        this.globalEncoders = globalEncoders</span>
<span class="fc" id="L76">        this.emptyResponse = noResponse</span>
    }

    @Override
    Request protocol(final String proto) {
<span class="fc" id="L81">        matchers &lt;&lt; RequestMatcher.protocol(equalToIgnoringCase(proto))</span>
<span class="pc" id="L82">        this</span>
    }

    @Override @SuppressWarnings('ConfusingMethodName')
    Request headers(final Map&lt;String, Object&gt; heads) {
<span class="fc" id="L87">        heads.each { k, v -&gt;</span>
<span class="pc" id="L88">            header k, v</span>
        }
<span class="pc" id="L90">        this</span>
    }

    @Override
    Request header(final String name, final String value) {
<span class="pc" id="L95">        header name, hasItem(value)</span>
    }

    @Override
    Request header(final String name, final Matcher&lt;Iterable&lt;String&gt;&gt; value) {
<span class="fc" id="L100">        matchers &lt;&lt; RequestMatcher.header(name, value)</span>
<span class="pc" id="L101">        this</span>
    }

    @Override
    Request query(final String name, final String value = null) {
<span class="pc bfc" id="L106" title="All 2 branches covered.">        query name, value != null ? contains(value) : contains('')</span>
    }

    @Override
    Request query(final String name, final Iterable&lt;String&gt; value) {
<span class="pc" id="L111">        query name, containsInAnyOrder((value as Collection&lt;String&gt;).collect { equalTo(it) })</span>
    }

    @Override
    Request query(final String name, final Matcher&lt;Iterable&lt;String&gt;&gt; matcher) {
<span class="fc" id="L116">        matchers &lt;&lt; RequestMatcher.query(name, matcher)</span>
<span class="pc" id="L117">        this</span>
    }

    @Override
    Request queries(final Map&lt;String, Object&gt; map) {
<span class="fc" id="L122">        map.each { k, v -&gt;</span>
<span class="pc" id="L123">            query k, v</span>
        }
<span class="pc" id="L125">        this</span>
    }

    @Override
    Request cookie(final String name, final String value) {
<span class="pc" id="L130">        cookie name, new CookieMatcher().value(value)</span>
    }

    @Override
    Request cookie(final String name, final Matcher&lt;Cookie&gt; value) {
<span class="fc" id="L135">        matchers &lt;&lt; RequestMatcher.cookie(name, value)</span>
<span class="pc" id="L136">        this</span>
    }

    @Override
    Request cookies(Matcher&lt;Map&lt;String, Cookie&gt;&gt; matcher) {
<span class="fc" id="L141">        matchers &lt;&lt; RequestMatcher.cookies(matcher)</span>
<span class="pc" id="L142">        this</span>
    }

    @Override @SuppressWarnings('ConfusingMethodName')
    Request cookies(Map&lt;String, Object&gt; cookies) {
<span class="fc" id="L147">        cookies.each { k, v -&gt;</span>
<span class="pc" id="L148">            cookie k, v</span>
        }
<span class="pc" id="L150">        this</span>
    }

    @Override
    Request listener(final Consumer&lt;ClientRequest&gt; listener) {
<span class="fc" id="L155">        listeners.add(listener)</span>
<span class="pc" id="L156">        this</span>
    }

    @Override
    Response responds() {
<span class="pc bpc" id="L161" title="2 of 4 branches missed.">        Response response = newResponse()</span>
<span class="fc" id="L162">        responses.add(response)</span>
<span class="pc" id="L163">        response</span>
    }

    @Override
    Request responder(final Consumer&lt;Response&gt; responder) {
<span class="pc bpc" id="L168" title="2 of 4 branches missed.">        Response response = newResponse()</span>
<span class="fc" id="L169">        responder.accept(response)</span>
<span class="fc" id="L170">        responses.add(response)</span>
<span class="pc" id="L171">        this</span>
    }

    @Override
    Request responder(@DelegatesTo(value = Response, strategy = DELEGATE_FIRST) final Closure closure) {
<span class="pc bpc" id="L176" title="2 of 4 branches missed.">        Response response = delegateTo(newResponse(), closure)</span>
<span class="fc" id="L177">        responses.add(response)</span>
<span class="pc" id="L178">        this</span>
    }

    @Override @SuppressWarnings('ConfusingMethodName')
    Request called(final Matcher&lt;Integer&gt; callVerifier) {
<span class="fc" id="L183">        this.callVerifier = callVerifier</span>
<span class="pc" id="L184">        this</span>
    }

    @Override @SuppressWarnings('ConfusingMethodName')
    Request called(final int count) {
<span class="pc" id="L189">        called equalTo(count)</span>
    }

    @Override
    Request matcher(final Matcher&lt;ClientRequest&gt; matcher) {
<span class="fc" id="L194">        matchers &lt;&lt; RequestMatcher.matcher(matcher)</span>
<span class="pc" id="L195">        this</span>
    }

    /**
     * Used to verify that the request has been called the expected number of times. By default there is no verification criteria, they must be
     * configured using one of the &lt;code&gt;called()&lt;/code&gt; methods.
     *
     * @return true if the call count matches the expected verification criteria
     */
    boolean verify() {
<span class="pc" id="L205">        callVerifier.matches(callCount)</span>
    }

    /**
     * Used to determine whether or not the incoming client request matches this configured request. All configured matchers must return
     * &lt;code&gt;true&lt;/code&gt; in order for the match to be successful. By default, all request have a matcher for request method and request path, the
     * others are optional.
     *
     * @param clientRequest the incoming client request
     * @return true if the incoming request matches the configured request
     */
    boolean matches(final ClientRequest clientRequest) {
<span class="pc" id="L217">        matchers.every { m -&gt;</span>
<span class="pc" id="L218">            m.matches(clientRequest)</span>
        }
    }

    /**
     * Used to retrieve the configured matchers in the request.
     *
     * @return an immutable list of the configured matchers.
     */
    List&lt;RequestMatcher&gt; getRequestMatchers() {
<span class="pc" id="L228">        matchers.asImmutable()</span>
    }

    protected void addMatcher(final RequestMatcher matcher) {
<span class="fc" id="L232">        matchers &lt;&lt; matcher</span>
    }

    private Response newResponse() {
<span class="pc" id="L236">        new ErsatzResponse(emptyResponse, globalEncoders)</span>
    }

    /**
     * Used to retrieve the current response in the response list (based on the call count). The last response in the list will be sent to all future
     * calls.
     *
     * @return the current response
     */
    Response getCurrentResponse() {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        int index = callCount &gt;= responses.size() ? responses.size() - 1 : callCount</span>
<span class="pc bpc" id="L247" title="10 of 16 branches missed.">        index &gt;= 0 ? responses[index] : null</span>
    }

    /**
     * Used to mark the request as having been called. Any configured listeners will be called after the call count has been incremented.
     */
    void mark(final ClientRequest cr) {
<span class="pc bpc" id="L254" title="3 of 6 branches missed.">        callCount++</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (final Consumer&lt;ClientRequest&gt; listener : listeners) {</span>
<span class="fc" id="L257">            listener.accept(cr)</span>
        }
    }

    @Override String toString() {
<span class="fc" id="L262">        StringBuilder str = new StringBuilder()</span>
<span class="fc" id="L263">        str.append &quot;Expectations (${getClass().simpleName}): &quot;</span>

<span class="fc" id="L265">        matchers.each { m -&gt;</span>
<span class="fc" id="L266">            StringDescription desc = new StringDescription()</span>
<span class="fc" id="L267">            m.matcher.describeTo(desc)</span>
<span class="pc" id="L268">            str.append(desc).append(', ')</span>
        }

<span class="pc" id="L271">        str.toString()</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>
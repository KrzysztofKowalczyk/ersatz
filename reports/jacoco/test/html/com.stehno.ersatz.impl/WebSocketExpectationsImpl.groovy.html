<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebSocketExpectationsImpl.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ersatz</a> &gt; <a href="index.source.html" class="el_package">com.stehno.ersatz.impl</a> &gt; <span class="el_source">WebSocketExpectationsImpl.groovy</span></div><h1>WebSocketExpectationsImpl.groovy</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Christopher J. Stehno
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.stehno.ersatz.impl

import com.stehno.ersatz.ReceivedMessage
import com.stehno.ersatz.SentMessage
import com.stehno.ersatz.WebSocketExpectations
import com.stehno.ersatz.WsMessageType
import io.undertow.websockets.core.BufferedBinaryMessage
import io.undertow.websockets.core.BufferedTextMessage

import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.function.Consumer

import static com.stehno.ersatz.WsMessageType.BINARY
import static com.stehno.ersatz.WsMessageType.TEXT
import static com.stehno.ersatz.WsMessageType.resolve
import static com.stehno.ersatz.impl.Delegator.delegateTo
import static groovy.lang.Closure.DELEGATE_FIRST
import static java.util.concurrent.TimeUnit.SECONDS

class WebSocketExpectationsImpl implements WebSocketExpectations {

<span class="fc" id="L38">    private final CountDownLatch connectionLatch = new CountDownLatch(1)</span>
<span class="fc" id="L39">    private final List&lt;ReceivedMessageImpl&gt; receivedMessages = []</span>
<span class="fc" id="L40">    private final List&lt;SentMessageImpl&gt; sentMessages = []</span>
    final String path

    WebSocketExpectationsImpl(final String path) {
<span class="fc" id="L44">        this.path = path</span>
    }

    void connect() {
<span class="fc" id="L48">        connectionLatch.countDown()</span>
    }

    boolean isConnected() {
<span class="nc" id="L52">        connectionLatch.count == 0</span>
    }

    @Override
    ReceivedMessage receive(Object payload) {
<span class="fc" id="L57">        switch (resolve(payload)) {</span>
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">            case BINARY:</span>
<span class="nc" id="L59">                return receive(payload, BINARY)</span>
            default:
<span class="pc" id="L61">                return receive(payload.toString(), TEXT)</span>
        }
    }

    @Override
    ReceivedMessage receive(Object payload, WsMessageType messageType) {
<span class="fc" id="L67">        ReceivedMessageImpl message = new ReceivedMessageImpl(payload: payload, messageType: messageType)</span>
<span class="fc" id="L68">        receivedMessages &lt;&lt; message</span>

<span class="pc" id="L70">        message</span>
    }

    @Override
    ReceivedMessage receive(@DelegatesTo(value = ReceivedMessage, strategy = DELEGATE_FIRST) Closure closure) {
<span class="fc" id="L75">        ReceivedMessageImpl message = delegateTo(new ReceivedMessageImpl(), closure)</span>
<span class="fc" id="L76">        receivedMessages &lt;&lt; message</span>
<span class="pc" id="L77">        message</span>
    }

    @Override
    SentMessage send(Object payload) {
<span class="nc" id="L82">        switch (resolve(payload)) {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">            case BINARY:</span>
<span class="nc" id="L84">                return send(payload, BINARY)</span>
            default:
<span class="nc" id="L86">                return send(payload.toString(), TEXT)</span>
        }
    }

    @Override
    SentMessage send(Object payload, WsMessageType messageType) {
<span class="fc" id="L92">        SentMessageImpl message = new SentMessageImpl(payload: payload, messageType: messageType)</span>
<span class="fc" id="L93">        sentMessages &lt;&lt; message</span>
<span class="pc" id="L94">        message</span>
    }

    @Override
    SentMessage send(@DelegatesTo(value = SentMessage, strategy = DELEGATE_FIRST) Closure closure) {
<span class="fc" id="L99">        SentMessageImpl message = delegateTo(new SentMessageImpl(), closure)</span>
<span class="fc" id="L100">        sentMessages &lt;&lt; message</span>
<span class="pc" id="L101">        message</span>
    }

    @Override
    ReceivedMessage receive(Consumer&lt;ReceivedMessage&gt; config) {
<span class="nc" id="L106">        ReceivedMessageImpl message = new ReceivedMessageImpl()</span>
<span class="nc" id="L107">        config.accept(message)</span>
<span class="nc" id="L108">        receivedMessages &lt;&lt; message</span>
<span class="nc" id="L109">        message</span>
    }

    @Override
    SentMessage send(Consumer&lt;SentMessage&gt; config) {
<span class="nc" id="L114">        SentMessageImpl message = new SentMessageImpl()</span>
<span class="nc" id="L115">        config.accept(message)</span>
<span class="nc" id="L116">        sentMessages &lt;&lt; message</span>
<span class="nc" id="L117">        message</span>
    }

    int getExpectedMessageCount() {
<span class="nc" id="L121">        receivedMessages.size()</span>
    }

    void eachSender(Closure closure) {
<span class="fc" id="L125">        sentMessages.each closure</span>
    }

    void eachMessage(Closure closure) {
<span class="nc" id="L129">        receivedMessages.each closure</span>
    }

    ReceivedMessageImpl findMatch(final BufferedTextMessage message) {
<span class="pc" id="L133">        receivedMessages.find { m -&gt; m.matches(message) }</span>
    }

    ReceivedMessageImpl findMatch(final BufferedBinaryMessage message) {
<span class="pc" id="L137">        receivedMessages.find { m -&gt; m.matches(message) }</span>
    }

    boolean verify(final long timeout = 1, final TimeUnit unit = SECONDS) {
<span class="pc bpc" id="L141" title="2 of 4 branches missed.">        connectionLatch.await(timeout, unit) &amp;&amp; receivedMessages.every { m -&gt; m.marked(timeout, unit) }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ErsatzServer.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ersatz</a> &gt; <a href="index.source.html" class="el_package">com.stehno.ersatz</a> &gt; <span class="el_source">ErsatzServer.groovy</span></div><h1>ErsatzServer.groovy</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Christopher J. Stehno
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.stehno.ersatz

import com.stehno.ersatz.auth.BasicAuthHandler
import com.stehno.ersatz.auth.DigestAuthHandler
import com.stehno.ersatz.auth.SimpleIdentityManager
import com.stehno.ersatz.impl.ErsatzRequest
import com.stehno.ersatz.impl.ExpectationsImpl
import com.stehno.ersatz.impl.UndertowClientRequest
import com.stehno.ersatz.impl.UnmatchedRequestReport
import groovy.transform.CompileStatic
import groovy.util.logging.Slf4j
import io.undertow.Undertow
import io.undertow.server.HttpHandler
import io.undertow.server.HttpServerExchange
import io.undertow.server.handlers.BlockingHandler
import io.undertow.server.handlers.CookieImpl
import io.undertow.server.handlers.HttpTraceHandler
import io.undertow.server.handlers.encoding.ContentEncodingRepository
import io.undertow.server.handlers.encoding.DeflateEncodingProvider
import io.undertow.server.handlers.encoding.EncodingHandler
import io.undertow.server.handlers.encoding.GzipEncodingProvider

import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import java.security.KeyStore
import java.util.function.BiFunction
import java.util.function.Consumer
import java.util.function.Function

import static groovy.transform.TypeCheckingMode.SKIP
import static io.undertow.util.HttpString.tryFromString

/**
 * The main entry point for configuring an Ersatz server, which allows configuring of the expectations and management of the server itself. This is
 * the class that should be instantiated in unit tests.
 *
 * The server will be started on an ephemeral port so as not to collide with itself or other server applications running in the test environment. In
 * your tests, you can retrieve the server port or URL using the &lt;code&gt;getPort()&lt;/code&gt; and &lt;code&gt;getServerUrl()&lt;/code&gt; methods respectively.
 *
 * Using the &lt;code&gt;ErsatzServer&lt;/code&gt; follows the workflow:
 *
 * &lt;ol&gt;
 *     &lt;li&gt;Create the &lt;code&gt;ErsatzServer&lt;/code&gt; instance.&lt;/li&gt;
 *     &lt;li&gt;Configure the expectations.&lt;/li&gt;
 *     &lt;li&gt;Start the server&lt;/li&gt;
 *     &lt;li&gt;Run your client tests against the server.&lt;/li&gt;
 *     &lt;li&gt;Verify the expectations.&lt;/li&gt;
 *     &lt;li&gt;Stop the server.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * See the &lt;a href=&quot;http://stehno.com/ersatz/guide/html5/&quot; target=&quot;_blank&quot;&gt;User Guide&lt;/a&gt; for more detailed information.
 */
@CompileStatic @Slf4j
class ErsatzServer implements ServerConfig {

    /**
     * The response body returned when no matching expectation could be found.
     */
    static final String NOT_FOUND_BODY = '404: Not Found'

    private static final String LOCALHOST = 'localhost'
    private static final int EPHEMERAL_PORT = 0
    private static final int UNSPECIFIED_PORT = -1
<span class="fc" id="L79">    private final RequestDecoders globalDecoders = new RequestDecoders()</span>
<span class="fc" id="L80">    private final ResponseEncoders globalEncoders = new ResponseEncoders()</span>
<span class="fc" id="L81">    private final ExpectationsImpl expectations = new ExpectationsImpl(globalDecoders, globalEncoders)</span>
    private Undertow server
    private boolean httpsEnabled
    private boolean autoStartEnabled = true
    private boolean started
    private boolean mismatchToConsole
    private URL keystoreLocation
    private String keystorePass = 'ersatz'
    private int actualHttpPort = UNSPECIFIED_PORT
    private int actualHttpsPort = UNSPECIFIED_PORT
    private AuthenticationConfig authenticationConfig

    /**
     * Creates a new Ersatz server instance with either the default configuration or a configuration provided by the Groovy DSL closure.
     *
     * @param closure the configuration closure (delegated to &lt;code&gt;ServerConfig&lt;/code&gt;)
     */
    ErsatzServer(@DelegatesTo(ServerConfig) final Closure closure = null) {
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (closure) {</span>
<span class="fc" id="L100">            closure.delegate = this</span>
<span class="fc" id="L101">            closure.call()</span>
        }
    }

    /**
     * Creates a new Ersatz server instance configured by the provided &lt;code&gt;Consumer&lt;/code&gt;, which will have an instance of &lt;code&gt;ServerConfig&lt;/code&gt;
     * passed into it for server configuration.
     *
     * @param consumer the configuration consumer
     */
    @SuppressWarnings('ThisReferenceEscapesConstructor')
    ErsatzServer(final Consumer&lt;ServerConfig&gt; consumer) {
<span class="fc" id="L113">        consumer.accept(this)</span>
    }

    /**
     * Used to control the enabled/disabled state of HTTPS on the server. By default HTTPS is disabled.
     *
     * @param enabled optional toggle value (true if not specified)
     * @return a reference to the server being configured
     */
    ErsatzServer https(boolean enabled = true) {
<span class="fc" id="L123">        httpsEnabled = enabled</span>
<span class="pc" id="L124">        this</span>
    }

    /**
     * Used to enable/disable the auto-start feature, which will start the server after any call to either of the &lt;code&gt;expectations&lt;/code&gt;
     * configuration methods. With this setting enabled, any other calls to the &lt;code&gt;start()&lt;/code&gt; method are ignored. Further configuration is
     * allowed.
     *
     * Auto-start is enabled by default.
     *
     * @param autoStart whether or not auto-start is enabled
     * @return a reference to the server being configured
     */
    ServerConfig autoStart(boolean autoStart) {
<span class="fc" id="L138">        autoStartEnabled = autoStart</span>
<span class="pc" id="L139">        this</span>
    }

    @Deprecated
    ServerConfig autoStart() {
<span class="nc" id="L144">        autoStart(true)</span>
    }

    /**
     * Used to toggle the console output of mismatched request reports. By default they are only rendered in the logging. A value of &lt;code&gt;true&lt;/code&gt;
     * will cause the report to be output on the console as well.
     *
     * @param toConsole whether or not the report should also be written to the console
     * @return a reference to the server being configured
     */
    @Override
    ServerConfig reportToConsole(boolean toConsole = true) {
<span class="nc" id="L156">        mismatchToConsole = toConsole</span>
<span class="nc" id="L157">        this</span>
    }

    /**
     * Allows configuration of an external HTTPS keystore with the given location and password. By default, if this is not specified an internally
     * provided keystore will be used for HTTPS certification. See the User Guide for details about configuring your own keystore.
     *
     * @param location the URL of the keystore file
     * @param password the keystore file password (defaults to &quot;ersatz&quot; if omitted)
     * @return a reference to the server being configured
     */
    ServerConfig keystore(final URL location, final String password = 'ersatz') {
<span class="nc" id="L169">        keystoreLocation = location</span>
<span class="nc" id="L170">        keystorePass = password</span>
<span class="nc" id="L171">        this</span>
    }

    /**
     * Used to retrieve the port where the HTTP server is running.
     *
     * @return the HTTP port
     */
    int getHttpPort() {
<span class="pc" id="L180">        actualHttpPort</span>
    }

    /**
     * Used to retrieve the port where the HTTPS server is running.
     *
     * @return the HTTPS port
     */
    int getHttpsPort() {
<span class="nc" id="L189">        actualHttpsPort</span>
    }

    /**
     * Used to retrieve the full URL of the HTTP server.
     *
     * @return the full URL of the HTTP server
     */
    String getHttpUrl() {
<span class="pc" id="L198">        &quot;http://localhost:$actualHttpPort&quot;</span>
    }

    /**
     * Used to retrieve the full URL of the HTTPS server.
     *
     * @return the full URL of the HTTP server
     */
    String getHttpsUrl() {
<span class="pc" id="L207">        &quot;https://localhost:$actualHttpsPort&quot;</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided &lt;code&gt;Consumer&lt;Expectations&gt;&lt;/code&gt; implementation will have an active
     * &lt;code&gt;Expectations&lt;/code&gt; object passed into it for configuring server interaction expectations.
     *
     * Calling this method when auto-start is enabled will start the server.
     *
     * @param expects the &lt;code&gt;Consumer&lt;Expectations&gt;&lt;/code&gt; instance to perform the configuration
     * @return a reference to this server
     */
    @SuppressWarnings('ConfusingMethodName')
    ErsatzServer expectations(final Consumer&lt;Expectations&gt; expects) {
<span class="fc" id="L221">        expects.accept(expectations)</span>

<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (autoStartEnabled) {</span>
<span class="fc" id="L224">            start()</span>
        }

<span class="pc" id="L227">        this</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided Groovy &lt;code&gt;Closure&lt;/code&gt; will delegate to an &lt;code&gt;Expectations&lt;/code&gt;
     * instance for configuring server interaction expectations using the Groovy DSL.
     *
     * Calling this method when auto-start is enabled will start the server.
     *
     * @param closure the Groovy &lt;code&gt;Closure&lt;/code&gt; which will provide expectation configuration via DSL
     * @return a reference to this server
     */
    @SuppressWarnings('ConfusingMethodName')
    ErsatzServer expectations(@DelegatesTo(Expectations) final Closure closure) {
<span class="fc" id="L241">        closure.delegate = expectations</span>
<span class="fc" id="L242">        closure.call()</span>

<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (autoStartEnabled) {</span>
<span class="fc" id="L245">            start()</span>
        }

<span class="pc" id="L248">        this</span>
    }

    /**
     * An alternate means of starting the expectation chain.
     *
     * Calling this method when auto-start is enabled will &lt;b&gt;NOT&lt;/b&gt; start the server. Use one of the other expectation configuration method if
     * auto-start functionality is desired.
     *
     * @return the reference to the Expectation configuration object
     */
    Expectations expects() {
<span class="pc" id="L260">        expectations</span>
    }

    /**
     * Configures the given request content decoder for the specified request content-type.
     *
     * @param contentType the request content-type
     * @param decoder the request content decoder
     * @return the reference to the server configuration
     */
    @Override
    ErsatzServer decoder(String contentType, BiFunction&lt;byte[], DecodingContext, Object&gt; decoder) {
<span class="nc" id="L272">        globalDecoders.register contentType, decoder</span>
<span class="nc" id="L273">        this</span>
    }

    /**
     * Configures the given request content decoder for the specified request content-type.
     *
     * @param contentType the request content-type
     * @param decoder the request content decoder
     * @return the reference to the server configuration
     */
    @Override
    ErsatzServer decoder(ContentType contentType, BiFunction&lt;byte[], DecodingContext, Object&gt; decoder) {
<span class="nc" id="L285">        globalDecoders.register contentType, decoder</span>
<span class="nc" id="L286">        this</span>
    }

    /**
     * Registers a response body encoder.
     *
     * param contentType the response content-type to be encoded
     * @param objectType the response object type to be encoded
     * @param encoder the encoder function
     * @return a reference to this server configuration
     */
    @Override
    ServerConfig encoder(String contentType, Class objectType, Function&lt;Object, String&gt; encoder) {
<span class="nc" id="L299">        globalEncoders.register contentType, objectType, encoder</span>
<span class="nc" id="L300">        this</span>
    }

    /**
     * Registers a response body encoder.
     *
     * param contentType the response content-type to be encoded
     * @param objectType the response object type to be encoded
     * @param encoder the encoder function
     * @return a reference to this server configuration
     */
    @Override
    ServerConfig encoder(ContentType contentType, Class objectType, Function&lt;Object, String&gt; encoder) {
<span class="fc" id="L313">        globalEncoders.register contentType, objectType, encoder</span>
<span class="pc" id="L314">        this</span>
    }

    /**
     * Registers authentication configuration as a Groovy Closure.
     *
     * @param closure the configuration closure
     * @return a reference to this server configuration
     */
    @Override
    ServerConfig authentication(@DelegatesTo(AuthenticationConfig) final Closure closure) {
<span class="fc" id="L325">        authenticationConfig = new AuthenticationConfig()</span>
<span class="fc" id="L326">        closure.delegate = authenticationConfig</span>
<span class="fc" id="L327">        closure.call()</span>
<span class="pc" id="L328">        this</span>
    }

    /**
     * Registers authentication configuration as a &lt;code&gt;Consumer&lt;AuthenticationConfig&gt;&lt;/code&gt;.
     *
     * @param config the configuration Consumer
     * @return a reference to this server configuration
     */
    @Override
    ServerConfig authentication(final Consumer&lt;AuthenticationConfig&gt; config) {
<span class="nc" id="L339">        authenticationConfig = new AuthenticationConfig()</span>
<span class="nc" id="L340">        config.accept(authenticationConfig)</span>
<span class="nc" id="L341">        return this</span>
    }

    /**
     * Used to start the HTTP server for test interactions. This method should be called after configuration of expectations and before the test
     * interactions are executed against the server.
     */
    @SuppressWarnings(['Println', 'DuplicateNumberLiteral'])
    void start() {
<span class="fc bfc" id="L350" title="All 4 branches covered.">        if (!started) {</span>
<span class="fc" id="L351">            Undertow.Builder builder = Undertow.builder().addHttpListener(EPHEMERAL_PORT, LOCALHOST)</span>

<span class="fc bfc" id="L353" title="All 2 branches covered.">            if (httpsEnabled) {</span>
<span class="fc" id="L354">                builder.addHttpsListener(EPHEMERAL_PORT, LOCALHOST, sslContext())</span>
            }

<span class="fc" id="L357">            BlockingHandler blockingHandler = new BlockingHandler(new EncodingHandler(</span>
<span class="fc" id="L358">                applyAuthentication(</span>
<span class="fc" id="L359">                    new HttpTraceHandler(</span>
<span class="fc" id="L360">                        new HttpHandler() {</span>
                            @Override void handleRequest(final HttpServerExchange exchange) throws Exception {
<span class="fc" id="L362">                                ClientRequest clientRequest = new UndertowClientRequest(exchange)</span>

<span class="fc" id="L364">                                log.debug 'Request: {}', clientRequest</span>

<span class="fc" id="L366">                                ErsatzRequest request = expectations.findMatch(clientRequest) as ErsatzRequest</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">                                if (request) {</span>
<span class="fc" id="L368">                                    Response currentResponse = request.currentResponse</span>
<span class="fc" id="L369">                                    request.mark(clientRequest)</span>
<span class="fc" id="L370">                                    send(exchange, currentResponse)</span>

                                } else {
<span class="fc" id="L373">                                    UnmatchedRequestReport report = new UnmatchedRequestReport(</span>
                                        clientRequest,
                                        expectations.requests as List&lt;ErsatzRequest&gt;
                                    )

<span class="fc" id="L378">                                    log.warn report.toString()</span>

<span class="pc bpc" id="L380" title="1 of 2 branches missed.">                                    if (mismatchToConsole) {</span>
<span class="nc" id="L381">                                        println report</span>
                                    }

<span class="fc" id="L384">                                    exchange.setStatusCode(404).responseSender.send(NOT_FOUND_BODY)</span>
                                }
                            }
                        }
                    )
                ),
<span class="fc" id="L390">                new ContentEncodingRepository()</span>
<span class="fc" id="L391">                    .addEncodingHandler('gzip', new GzipEncodingProvider(), 50)</span>
<span class="fc" id="L392">                    .addEncodingHandler('deflate', new DeflateEncodingProvider(), 50)</span>
            ))

<span class="fc" id="L395">            server = builder.setHandler(blockingHandler).build()</span>

<span class="fc" id="L397">            server.start()</span>

<span class="fc" id="L399">            applyPorts()</span>

<span class="fc" id="L401">            started = true</span>
        }
    }

    /**
     * Clears all configured expectations from the server. Does not affect global encoders or decoders.
     */
    void clearExpectations() {
<span class="fc" id="L409">        expectations.clear()</span>
    }

    /**
     * Used to stop the HTTP server. The server may be restarted after it has been stopped.
     */
    void stop() {
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (started) {</span>
<span class="fc" id="L417">            actualHttpPort = UNSPECIFIED_PORT</span>
<span class="fc" id="L418">            actualHttpsPort = UNSPECIFIED_PORT</span>

<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            server?.stop()</span>

<span class="fc" id="L422">            started = false</span>
        }
    }

    /**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back from
     * the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     */
    boolean verify() {
<span class="pc" id="L434">        expectations.verify()</span>
    }

    private HttpHandler applyAuthentication(final HttpHandler handler) {
<span class="fc" id="L438">        HttpHandler result = handler</span>

<span class="fc bfc" id="L440" title="All 2 branches covered.">        if (authenticationConfig) {</span>
<span class="fc" id="L441">            SimpleIdentityManager identityManager = new SimpleIdentityManager(authenticationConfig.username, authenticationConfig.password)</span>
<span class="fc" id="L442">            switch (authenticationConfig.type) {</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">                case Authentication.BASIC:</span>
<span class="fc" id="L444">                    result = new BasicAuthHandler(identityManager).apply(result)</span>
<span class="pc" id="L445">                    break</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">                case Authentication.DIGEST:</span>
<span class="fc" id="L447">                    result = new DigestAuthHandler(identityManager).apply(result)</span>
<span class="fc" id="L448">                    break</span>
                default:
<span class="nc" id="L450">                    throw new IllegalArgumentException('Invalid authentication configuration.')</span>
            }
        }

<span class="pc" id="L454">        result</span>
    }

    private static void send(final HttpServerExchange exchange, final Response response) {
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        if (response) {</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            if (response.delay) {</span>
<span class="fc" id="L460">                sleep response.delay</span>
            }

<span class="fc" id="L463">            exchange.statusCode = response.code</span>

<span class="fc" id="L465">            response.headers.each { String k, List&lt;String&gt; v -&gt;</span>
<span class="pc" id="L466">                v.each { String value -&gt;</span>
<span class="pc" id="L467">                    exchange.responseHeaders.add(tryFromString(k), value)</span>
                }
            }

<span class="fc" id="L471">            response.cookies.each { k, v -&gt;</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">                if (v instanceof Cookie) {</span>
<span class="fc" id="L473">                    Cookie ersatzCookie = v as Cookie</span>
<span class="fc" id="L474">                    CookieImpl cookie = new CookieImpl(k, ersatzCookie.value)</span>
<span class="fc" id="L475">                    cookie.path = ersatzCookie.path</span>
<span class="fc" id="L476">                    cookie.domain = ersatzCookie.domain</span>
<span class="fc" id="L477">                    cookie.maxAge = ersatzCookie.maxAge</span>
<span class="fc" id="L478">                    cookie.secure = ersatzCookie.secure</span>
<span class="fc" id="L479">                    cookie.version = ersatzCookie.version</span>
<span class="fc" id="L480">                    cookie.httpOnly = ersatzCookie.httpOnly</span>
<span class="fc" id="L481">                    cookie.setComment(ersatzCookie.comment)</span>
<span class="pc" id="L482">                    exchange.responseCookies.put(k, cookie)</span>

                } else {
<span class="pc" id="L485">                    exchange.responseCookies.put(k, new CookieImpl(k, v as String))</span>
                }
            }
        }

<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        String responseContent = response?.content</span>

<span class="pc bpc" id="L492" title="2 of 6 branches missed.">        log.debug 'Response({}): {}', exchange.responseHeaders ?: '&lt;no-headers&gt;', responseContent.take(1000) ?: '&lt;empty&gt;'</span>

<span class="fc" id="L494">        exchange.responseSender.send(responseContent)</span>
    }

    private void applyPorts() {
<span class="fc" id="L498">        actualHttpPort = (server.listenerInfo[0].address as InetSocketAddress).port</span>

<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (httpsEnabled) {</span>
<span class="fc" id="L501">            actualHttpsPort = (server.listenerInfo[1].address as InetSocketAddress).port</span>
        }
    }

    @CompileStatic(SKIP)
    private SSLContext sslContext() {
<span class="fc" id="L507">        KeyStore keyStore = KeyStore.getInstance('JKS')</span>

<span class="pc bpc" id="L509" title="1 of 2 branches missed.">        (keystoreLocation ?: ErsatzServer.getResource('/ersatz.keystore')).withInputStream { instr -&gt;</span>
<span class="pc" id="L510">            keyStore.load(instr, keystorePass.toCharArray())</span>
        }

<span class="fc" id="L513">        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.defaultAlgorithm)</span>
<span class="fc" id="L514">        keyManagerFactory.init(keyStore, keystorePass.toCharArray())</span>

<span class="fc" id="L516">        SSLContext sslContext = SSLContext.getInstance('TLS')</span>
<span class="fc" id="L517">        sslContext.init(keyManagerFactory.keyManagers, null, null)</span>

<span class="pc" id="L519">        sslContext</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ErsatzServer.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ersatz</a> &gt; <a href="index.source.html" class="el_package">com.stehno.ersatz</a> &gt; <span class="el_source">ErsatzServer.groovy</span></div><h1>ErsatzServer.groovy</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Christopher J. Stehno
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.stehno.ersatz

import com.stehno.ersatz.auth.BasicAuthHandler
import com.stehno.ersatz.auth.DigestAuthHandler
import com.stehno.ersatz.auth.SimpleIdentityManager
import com.stehno.ersatz.impl.*
import groovy.transform.CompileStatic
import groovy.util.logging.Slf4j
import io.undertow.Undertow
import io.undertow.server.HttpHandler
import io.undertow.server.HttpServerExchange
import io.undertow.server.handlers.BlockingHandler
import io.undertow.server.handlers.CookieImpl
import io.undertow.server.handlers.HttpTraceHandler
import io.undertow.server.handlers.encoding.ContentEncodingRepository
import io.undertow.server.handlers.encoding.DeflateEncodingProvider
import io.undertow.server.handlers.encoding.EncodingHandler
import io.undertow.server.handlers.encoding.GzipEncodingProvider

import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import java.security.KeyStore
import java.util.concurrent.TimeUnit
import java.util.function.BiFunction
import java.util.function.Consumer
import java.util.function.Function

import static groovy.transform.TypeCheckingMode.SKIP
import static io.undertow.UndertowOptions.IDLE_TIMEOUT
import static io.undertow.UndertowOptions.REQUEST_PARSE_TIMEOUT
import static io.undertow.util.HttpString.tryFromString
import static java.util.concurrent.TimeUnit.MILLISECONDS
import static java.util.concurrent.TimeUnit.SECONDS

/**
 * The main entry point for configuring an Ersatz server, which allows configuring of the expectations and management of the server itself. This is
 * the class that should be instantiated in unit tests.
 *
 * The server will be started on an ephemeral port so as not to collide with itself or other server applications running in the test environment. In
 * your tests, you can retrieve the server port or URL using the &lt;code&gt;getPort()&lt;/code&gt; and &lt;code&gt;getServerUrl()&lt;/code&gt; methods respectively.
 *
 * Using the &lt;code&gt;ErsatzServer&lt;/code&gt; follows the workflow:
 *
 * &lt;ol&gt;
 *     &lt;li&gt;Create the &lt;code&gt;ErsatzServer&lt;/code&gt; instance.&lt;/li&gt;
 *     &lt;li&gt;Configure the expectations.&lt;/li&gt;
 *     &lt;li&gt;Start the server&lt;/li&gt;
 *     &lt;li&gt;Run your client tests against the server.&lt;/li&gt;
 *     &lt;li&gt;Verify the expectations.&lt;/li&gt;
 *     &lt;li&gt;Stop the server.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * See the &lt;a href=&quot;http://stehno.com/ersatz/asciidoc/html5/&quot; target=&quot;_blank&quot;&gt;User Guide&lt;/a&gt; for more detailed information.
 */
@CompileStatic
@Slf4j
class ErsatzServer implements ServerConfig, Closeable {

    /**
     * The response body returned when no matching expectation could be found.
     */
    static final String NOT_FOUND_BODY = '404: Not Found'

    private static final String LOCALHOST = 'localhost'
    private static final int EPHEMERAL_PORT = 0
    private static final int UNSPECIFIED_PORT = -1
<span class="fc" id="L82">    private final RequestDecoders globalDecoders = new RequestDecoders()</span>
<span class="fc" id="L83">    private final ResponseEncoders globalEncoders = new ResponseEncoders()</span>
<span class="fc" id="L84">    private final ExpectationsImpl expectations = new ExpectationsImpl(globalDecoders, globalEncoders)</span>
    private Undertow server
    private boolean httpsEnabled
    private boolean autoStartEnabled = true
    private boolean started
    private boolean mismatchToConsole
    private URL keystoreLocation
    private String keystorePass = 'ersatz'
    private int actualHttpPort = UNSPECIFIED_PORT
    private int actualHttpsPort = UNSPECIFIED_PORT
    private AuthenticationConfig authenticationConfig
<span class="pc" id="L95">    private Closure&lt;Void&gt; timeoutConfig = { b -&gt; }</span>

    /**
     * Creates a new Ersatz server instance with either the default configuration or a configuration provided by the Groovy DSL closure.
     *
     * @param closure the configuration closure (delegated to &lt;code&gt;ServerConfig&lt;/code&gt;)
     */
    ErsatzServer(@DelegatesTo(ServerConfig) final Closure closure = null) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (closure) {</span>
<span class="fc" id="L104">            closure.delegate = this</span>
<span class="fc" id="L105">            closure.call()</span>
        }
    }

    /**
     * Creates a new Ersatz server instance configured by the provided &lt;code&gt;Consumer&lt;/code&gt;, which will have an instance of &lt;code&gt;ServerConfig&lt;/code&gt;
     * passed into it for server configuration.
     *
     * @param consumer the configuration consumer
     */
    @SuppressWarnings('ThisReferenceEscapesConstructor')
    ErsatzServer(final Consumer&lt;ServerConfig&gt; consumer) {
<span class="fc" id="L117">        consumer.accept(this)</span>
    }

    /**
     * Used to control the enabled/disabled state of HTTPS on the server. By default HTTPS is disabled.
     *
     * @param enabled optional toggle value (true if not specified)
     * @return a reference to the server being configured
     */
    ErsatzServer https(boolean enabled = true) {
<span class="fc" id="L127">        httpsEnabled = enabled</span>
<span class="pc" id="L128">        this</span>
    }

    /**
     * Used to enable/disable the auto-start feature, which will start the server after any call to either of the &lt;code&gt;expectations&lt;/code&gt;
     * configuration methods. With this setting enabled, any other calls to the &lt;code&gt;start()&lt;/code&gt; method are ignored. Further configuration is
     * allowed.
     *
     * Auto-start is enabled by default.
     *
     * @param autoStart whether or not auto-start is enabled
     * @return a reference to the server being configured
     */
    ServerConfig autoStart(boolean autoStart) {
<span class="fc" id="L142">        autoStartEnabled = autoStart</span>
<span class="pc" id="L143">        this</span>
    }

    @Deprecated
    ServerConfig autoStart() {
<span class="nc" id="L148">        autoStart(true)</span>
    }

    /**
     * Used to specify the server request timeout property value on the server. If not specified, &lt;code&gt;SECONDS&lt;/code&gt; will be used as the units.
     *
     * @param value the timeout value
     * @param units the units the timeout is specified with (or &lt;code&gt;SECONDS&lt;/code&gt;)
     * @return a reference to the server being configured
     */
    ServerConfig timeout(final int value, final TimeUnit units = SECONDS) {
<span class="fc" id="L159">        timeoutConfig = { Undertow.Builder builder -&gt;</span>
<span class="fc" id="L160">            builder.setServerOption(IDLE_TIMEOUT, MILLISECONDS.convert(value, units) as Integer)</span>
<span class="fc" id="L161">            builder.setServerOption(REQUEST_PARSE_TIMEOUT, MILLISECONDS.convert(value, units) as Integer)</span>
<span class="pc" id="L162">            null</span>
        }
<span class="pc" id="L164">        this</span>
    }

    /**
     * Used to toggle the console output of mismatched request reports. By default they are only rendered in the logging. A value of &lt;code&gt;true&lt;/code&gt;
     * will cause the report to be output on the console as well.
     *
     * @param toConsole whether or not the report should also be written to the console
     * @return a reference to the server being configured
     */
    @Override
    ServerConfig reportToConsole(boolean toConsole = true) {
<span class="nc" id="L176">        mismatchToConsole = toConsole</span>
<span class="nc" id="L177">        this</span>
    }

    /**
     * Allows configuration of an external HTTPS keystore with the given location and password. By default, if this is not specified an internally
     * provided keystore will be used for HTTPS certification. See the User Guide for details about configuring your own keystore.
     *
     * @param location the URL of the keystore file
     * @param password the keystore file password (defaults to &quot;ersatz&quot; if omitted)
     * @return a reference to the server being configured
     */
    ServerConfig keystore(final URL location, final String password = 'ersatz') {
<span class="nc" id="L189">        keystoreLocation = location</span>
<span class="nc" id="L190">        keystorePass = password</span>
<span class="nc" id="L191">        this</span>
    }

    /**
     * Used to retrieve the port where the HTTP server is running.
     *
     * @return the HTTP port
     */
    int getHttpPort() {
<span class="pc" id="L200">        actualHttpPort</span>
    }

    /**
     * Used to retrieve the port where the HTTPS server is running.
     *
     * @return the HTTPS port
     */
    int getHttpsPort() {
<span class="nc" id="L209">        actualHttpsPort</span>
    }

    /**
     * Used to retrieve the full URL of the HTTP server.
     *
     * @return the full URL of the HTTP server
     */
    String getHttpUrl() {
<span class="pc" id="L218">        &quot;http://localhost:$actualHttpPort&quot;</span>
    }

    /**
     * Used to retrieve the Web Socket URL.
     *
     * @return the web socket URL
     */
    String getWsUrl() {
<span class="pc" id="L227">        &quot;ws://localhost:$actualHttpPort&quot;</span>
    }

    /**
     * Used to retrieve the full URL of the HTTPS server.
     *
     * @return the full URL of the HTTP server
     */
    String getHttpsUrl() {
<span class="pc" id="L236">        &quot;https://localhost:$actualHttpsPort&quot;</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided &lt;code&gt;Consumer&lt;Expectations&gt;&lt;/code&gt; implementation will have an active
     * &lt;code&gt;Expectations&lt;/code&gt; object passed into it for configuring server interaction expectations.
     *
     * Calling this method when auto-start is enabled will start the server.
     *
     * @param expects the &lt;code&gt;Consumer&lt;Expectations&gt;&lt;/code&gt; instance to perform the configuration
     * @return a reference to this server
     */
    @SuppressWarnings('ConfusingMethodName')
    ErsatzServer expectations(final Consumer&lt;Expectations&gt; expects) {
<span class="fc" id="L250">        expects.accept(expectations)</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (autoStartEnabled) {</span>
<span class="fc" id="L253">            start()</span>
        }

<span class="pc" id="L256">        this</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided Groovy &lt;code&gt;Closure&lt;/code&gt; will delegate to an &lt;code&gt;Expectations&lt;/code&gt;
     * instance for configuring server interaction expectations using the Groovy DSL.
     *
     * Calling this method when auto-start is enabled will start the server.
     *
     * @param closure the Groovy &lt;code&gt;Closure&lt;/code&gt; which will provide expectation configuration via DSL
     * @return a reference to this server
     */
    @SuppressWarnings('ConfusingMethodName')
    ErsatzServer expectations(@DelegatesTo(Expectations) final Closure closure) {
<span class="fc" id="L270">        closure.delegate = expectations</span>
<span class="fc" id="L271">        closure.call()</span>

<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (autoStartEnabled) {</span>
<span class="fc" id="L274">            start()</span>
        }

<span class="pc" id="L277">        this</span>
    }

    /**
     * An alternate means of starting the expectation chain.
     *
     * Calling this method when auto-start is enabled will &lt;b&gt;NOT&lt;/b&gt; start the server. Use one of the other expectation configuration method if
     * auto-start functionality is desired.
     *
     * @return the reference to the Expectation configuration object
     */
    Expectations expects() {
<span class="pc" id="L289">        expectations</span>
    }

    /**
     * Configures the given request content decoder for the specified request content-type.
     *
     * @param contentType the request content-type
     * @param decoder the request content decoder
     * @return the reference to the server configuration
     */
    @Override
    ErsatzServer decoder(String contentType, BiFunction&lt;byte[], DecodingContext, Object&gt; decoder) {
<span class="nc" id="L301">        globalDecoders.register contentType, decoder</span>
<span class="nc" id="L302">        this</span>
    }

    /**
     * Configures the given request content decoder for the specified request content-type.
     *
     * @param contentType the request content-type
     * @param decoder the request content decoder
     * @return the reference to the server configuration
     */
    @Override
    ErsatzServer decoder(ContentType contentType, BiFunction&lt;byte[], DecodingContext, Object&gt; decoder) {
<span class="fc" id="L314">        globalDecoders.register contentType, decoder</span>
<span class="pc" id="L315">        this</span>
    }

    /**
     * Registers a response body encoder.
     *
     * param contentType the response content-type to be encoded
     * @param objectType the response object type to be encoded
     * @param encoder the encoder function
     * @return a reference to this server configuration
     */
    @Override
    ServerConfig encoder(String contentType, Class objectType, Function&lt;Object, String&gt; encoder) {
<span class="nc" id="L328">        globalEncoders.register contentType, objectType, encoder</span>
<span class="nc" id="L329">        this</span>
    }

    /**
     * Registers a response body encoder.
     *
     * param contentType the response content-type to be encoded
     * @param objectType the response object type to be encoded
     * @param encoder the encoder function
     * @return a reference to this server configuration
     */
    @Override
    ServerConfig encoder(ContentType contentType, Class objectType, Function&lt;Object, String&gt; encoder) {
<span class="fc" id="L342">        globalEncoders.register contentType, objectType, encoder</span>
<span class="pc" id="L343">        this</span>
    }

    /**
     * Registers authentication configuration as a Groovy Closure.
     *
     * @param closure the configuration closure
     * @return a reference to this server configuration
     */
    @Override
    ServerConfig authentication(@DelegatesTo(AuthenticationConfig) final Closure closure) {
<span class="fc" id="L354">        authenticationConfig = new AuthenticationConfig()</span>
<span class="fc" id="L355">        closure.delegate = authenticationConfig</span>
<span class="fc" id="L356">        closure.call()</span>
<span class="pc" id="L357">        this</span>
    }

    /**
     * Registers authentication configuration as a &lt;code&gt;Consumer&lt;AuthenticationConfig&gt;&lt;/code&gt;.
     *
     * @param config the configuration Consumer
     * @return a reference to this server configuration
     */
    @Override
    ServerConfig authentication(final Consumer&lt;AuthenticationConfig&gt; config) {
<span class="nc" id="L368">        authenticationConfig = new AuthenticationConfig()</span>
<span class="nc" id="L369">        config.accept(authenticationConfig)</span>
<span class="nc" id="L370">        return this</span>
    }

    /**
     * Used to start the HTTP server for test interactions. This method should be called after configuration of expectations and before the test
     * interactions are executed against the server.
     */
    @SuppressWarnings(['Println', 'DuplicateNumberLiteral'])
    void start() {
<span class="fc bfc" id="L379" title="All 4 branches covered.">        if (!started) {</span>
<span class="fc" id="L380">            Undertow.Builder builder = Undertow.builder().addHttpListener(EPHEMERAL_PORT, LOCALHOST)</span>
<span class="fc" id="L381">            timeoutConfig.call(builder)</span>

<span class="fc bfc" id="L383" title="All 2 branches covered.">            if (httpsEnabled) {</span>
<span class="fc" id="L384">                builder.addHttpsListener(EPHEMERAL_PORT, LOCALHOST, sslContext())</span>
            }

<span class="fc" id="L387">            BlockingHandler blockingHandler = new BlockingHandler(new EncodingHandler(</span>
<span class="fc" id="L388">                applyAuthentication(</span>
<span class="fc" id="L389">                    new HttpTraceHandler(</span>
<span class="fc" id="L390">                        new HttpHandler() {</span>
                            @Override
                            void handleRequest(final HttpServerExchange exchange) throws Exception {
<span class="fc" id="L393">                                ClientRequest clientRequest = new UndertowClientRequest(exchange)</span>

<span class="fc" id="L395">                                log.debug 'Request: {}', clientRequest</span>

<span class="fc" id="L397">                                ErsatzRequest request = expectations.findMatch(clientRequest) as ErsatzRequest</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                                if (request) {</span>
<span class="fc" id="L399">                                    Response currentResponse = request.currentResponse</span>
<span class="fc" id="L400">                                    request.mark(clientRequest)</span>
<span class="fc" id="L401">                                    send(exchange, currentResponse)</span>

                                } else {
<span class="fc" id="L404">                                    UnmatchedRequestReport report = new UnmatchedRequestReport(</span>
                                        clientRequest,
                                        expectations.requests as List&lt;ErsatzRequest&gt;
                                    )

<span class="fc" id="L409">                                    log.warn report.toString()</span>

<span class="pc bpc" id="L411" title="1 of 2 branches missed.">                                    if (mismatchToConsole) {</span>
<span class="nc" id="L412">                                        println report</span>
                                    }

<span class="fc" id="L415">                                    exchange.setStatusCode(404).responseSender.send(NOT_FOUND_BODY)</span>
                                }
                            }
                        }
                    )
                ),
<span class="fc" id="L421">                new ContentEncodingRepository()</span>
<span class="fc" id="L422">                    .addEncodingHandler('gzip', new GzipEncodingProvider(), 50)</span>
<span class="fc" id="L423">                    .addEncodingHandler('deflate', new DeflateEncodingProvider(), 50)</span>
            ))

<span class="fc" id="L426">            WebSocketsHandlerBuilder wsBuilder = new WebSocketsHandlerBuilder(expectations, blockingHandler, mismatchToConsole)</span>

<span class="fc" id="L428">            server = builder.setHandler(wsBuilder.build()).build()</span>
<span class="fc" id="L429">            server.start()</span>

<span class="fc" id="L431">            applyPorts()</span>

<span class="fc" id="L433">            started = true</span>
        }
    }

    /**
     * Clears all configured expectations from the server. Does not affect global encoders or decoders.
     */
    void clearExpectations() {
<span class="fc" id="L441">        expectations.clear()</span>
    }

    /**
     * Used to stop the HTTP server. The server may be restarted after it has been stopped.
     */
    void stop() {
<span class="fc bfc" id="L448" title="All 2 branches covered.">        if (started) {</span>
<span class="fc" id="L449">            actualHttpPort = UNSPECIFIED_PORT</span>
<span class="fc" id="L450">            actualHttpsPort = UNSPECIFIED_PORT</span>

<span class="pc bpc" id="L452" title="1 of 2 branches missed.">            server?.stop()</span>

<span class="fc" id="L454">            started = false</span>
        }
    }

    /**
     * An alias to the &lt;code&gt;stop()&lt;/code&gt; method.
     */
    @Override
    void close(){
<span class="fc" id="L463">        stop()</span>
    }

/**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back
     * from the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * If there are web socket expectations configured, this method will be blocking against the expected operations. Expectations involving web
     * sockets should consider using the timeout parameters - the default is 1s.
     *
     * @param timeout the timeout value (defaults to 1)
     * @param unit the timeout unit (defaults to SECONDS)
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     */
    boolean verify(final long timeout = 1, final TimeUnit unit = SECONDS) {
<span class="pc" id="L479">        expectations.verify(timeout, unit)</span>
    }

    private HttpHandler applyAuthentication(final HttpHandler handler) {
<span class="fc" id="L483">        HttpHandler result = handler</span>

<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (authenticationConfig) {</span>
<span class="fc" id="L486">            SimpleIdentityManager identityManager = new SimpleIdentityManager(authenticationConfig.username, authenticationConfig.password)</span>
<span class="fc" id="L487">            switch (authenticationConfig.type) {</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">                case Authentication.BASIC:</span>
<span class="fc" id="L489">                    result = new BasicAuthHandler(identityManager).apply(result)</span>
<span class="pc" id="L490">                    break</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">                case Authentication.DIGEST:</span>
<span class="fc" id="L492">                    result = new DigestAuthHandler(identityManager).apply(result)</span>
<span class="fc" id="L493">                    break</span>
                default:
<span class="nc" id="L495">                    throw new IllegalArgumentException('Invalid authentication configuration.')</span>
            }
        }

<span class="pc" id="L499">        result</span>
    }

    private static void send(final HttpServerExchange exchange, final Response response) {
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        if (response) {</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">            if (response.delay) {</span>
<span class="fc" id="L505">                sleep response.delay</span>
            }

<span class="fc" id="L508">            exchange.statusCode = response.code</span>

<span class="fc" id="L510">            response.headers.each { String k, List&lt;String&gt; v -&gt;</span>
<span class="pc" id="L511">                v.each { String value -&gt;</span>
<span class="pc" id="L512">                    exchange.responseHeaders.add(tryFromString(k), value)</span>
                }
            }

<span class="fc" id="L516">            response.cookies.each { k, v -&gt;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                if (v instanceof Cookie) {</span>
<span class="fc" id="L518">                    Cookie ersatzCookie = v as Cookie</span>
<span class="pc" id="L519">                    exchange.responseCookies.put k, new CookieImpl(k, ersatzCookie.value).with {</span>
<span class="fc" id="L520">                        path = ersatzCookie.path</span>
<span class="fc" id="L521">                        domain = ersatzCookie.domain</span>
<span class="fc" id="L522">                        maxAge = ersatzCookie.maxAge</span>
<span class="fc" id="L523">                        secure = ersatzCookie.secure</span>
<span class="fc" id="L524">                        version = ersatzCookie.version</span>
<span class="fc" id="L525">                        httpOnly = ersatzCookie.httpOnly</span>
<span class="pc" id="L526">                        setComment(ersatzCookie.comment)</span>
                    } as CookieImpl

                } else {
<span class="pc" id="L530">                    exchange.responseCookies.put(k, new CookieImpl(k, v as String))</span>
                }
            }
        }

<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        String responseContent = response?.content</span>

<span class="pc bpc" id="L537" title="2 of 6 branches missed.">        log.debug 'Response({}): {}', exchange.responseHeaders ?: '&lt;no-headers&gt;', responseContent.take(1000) ?: '&lt;empty&gt;'</span>

<span class="fc" id="L539">        exchange.responseSender.send(responseContent)</span>
    }

    private void applyPorts() {
<span class="fc" id="L543">        actualHttpPort = (server.listenerInfo[0].address as InetSocketAddress).port</span>

<span class="fc bfc" id="L545" title="All 2 branches covered.">        if (httpsEnabled) {</span>
<span class="fc" id="L546">            actualHttpsPort = (server.listenerInfo[1].address as InetSocketAddress).port</span>
        }
    }

    @CompileStatic(SKIP)
    private SSLContext sslContext() {
<span class="fc" id="L552">        KeyStore keyStore = KeyStore.getInstance('JKS')</span>

<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        (keystoreLocation ?: ErsatzServer.getResource('/ersatz.keystore')).withInputStream { instr -&gt;</span>
<span class="pc" id="L555">            keyStore.load(instr, keystorePass.toCharArray())</span>
        }

<span class="fc" id="L558">        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.defaultAlgorithm)</span>
<span class="fc" id="L559">        keyManagerFactory.init(keyStore, keystorePass.toCharArray())</span>

<span class="fc" id="L561">        SSLContext sslContext = SSLContext.getInstance('TLS')</span>
<span class="fc" id="L562">        sslContext.init(keyManagerFactory.keyManagers, null, null)</span>

<span class="pc" id="L564">        sslContext</span>
    }
}


</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>
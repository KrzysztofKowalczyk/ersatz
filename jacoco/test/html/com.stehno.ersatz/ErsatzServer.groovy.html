<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ErsatzServer.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ersatz</a> &gt; <a href="index.source.html" class="el_package">com.stehno.ersatz</a> &gt; <span class="el_source">ErsatzServer.groovy</span></div><h1>ErsatzServer.groovy</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Christopher J. Stehno
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.stehno.ersatz

import com.stehno.ersatz.impl.ErsatzRequest
import com.stehno.ersatz.impl.ExpectationsImpl
import com.stehno.ersatz.impl.UndertowClientRequest
import groovy.transform.CompileStatic
import groovy.transform.TypeCheckingMode
import groovy.util.logging.Slf4j
import io.undertow.Undertow
import io.undertow.server.HttpHandler
import io.undertow.server.HttpServerExchange
import io.undertow.server.handlers.BlockingHandler
import io.undertow.server.handlers.CookieImpl
import io.undertow.util.HttpString

import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import java.security.KeyStore
import java.util.function.BiFunction
import java.util.function.Consumer
import java.util.function.Function

/**
 * The main entry point for configuring an Ersatz server, which allows configuring of the expectations and management of the server itself. This is
 * the class that should be instantiated in unit tests.
 *
 * The server will be started on an ephemeral port so as not to collide with itself or other server applications running in the test environment. In
 * your tests, you can retrieve the server port or URL using the &lt;code&gt;getPort()&lt;/code&gt; and &lt;code&gt;getServerUrl()&lt;/code&gt; methods respectively.
 *
 * Using the &lt;code&gt;ErsatzServer&lt;/code&gt; follows the workflow:
 *
 * &lt;ol&gt;
 *     &lt;li&gt;Create the &lt;code&gt;ErsatzServer&lt;/code&gt; instance.&lt;/li&gt;
 *     &lt;li&gt;Configure the expectations.&lt;/li&gt;
 *     &lt;li&gt;Start the server&lt;/li&gt;
 *     &lt;li&gt;Run your client tests against the server.&lt;/li&gt;
 *     &lt;li&gt;Verify the expectations.&lt;/li&gt;
 *     &lt;li&gt;Stop the server.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * See the &lt;a href=&quot;http://stehno.com/ersatz/guide/html5/&quot; target=&quot;_blank&quot;&gt;User Guide&lt;/a&gt; for more detailed information.
 */
@CompileStatic @Slf4j
class ErsatzServer implements ServerConfig {

    /**
     * The response body returned when no matching expectation could be found.
     */
    static final String NOT_FOUND_BODY = '404: Not Found'

    private static final String LOCALHOST = 'localhost'
    private static final int EPHEMERAL_PORT = 0
<span class="fc" id="L68">    private final RequestDecoders globalDecoders = new RequestDecoders()</span>
<span class="fc" id="L69">    private final ResponseEncoders globalEncoders = new ResponseEncoders()</span>
<span class="fc" id="L70">    private final ExpectationsImpl expectations = new ExpectationsImpl(globalDecoders, globalEncoders)</span>
<span class="fc" id="L71">    private final List&lt;ServerFeature&gt; features = []</span>
    private Undertow server
    private boolean httpsEnabled
    private URL keystoreLocation
    private String keystorePass = 'ersatz'
    private int actualHttpPort = -1
    private int actualHttpsPort = -1

    /**
     * Creates a new Ersatz server instance with either the default configuration or a configuration provided by the Groovy DSL closure.
     *
     * @param closure the configuration closure (delegated to &lt;code&gt;ServerConfig&lt;/code&gt;)
     */
    ErsatzServer(@DelegatesTo(ServerConfig) final Closure closure = null) {
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (closure) {</span>
<span class="fc" id="L86">            closure.delegate = this</span>
<span class="fc" id="L87">            closure.call()</span>
        }
    }

    /**
     * Creates a new Ersatz server instance configured by the provided &lt;code&gt;Consumer&lt;/code&gt;, which will have an instance of &lt;code&gt;ServerConfig&lt;/code&gt;
     * passed into it for server configuration.
     *
     * @param consumer the configuration consumer
     */
    ErsatzServer(final Consumer&lt;ServerConfig&gt; consumer) {
<span class="fc" id="L98">        consumer.accept(this)</span>
    }

    /**
     * Used to enable support for a feature extension.
     *
     * @param feature the &lt;code&gt;ServerFeature&lt;/code&gt; to be added
     * @return a reference to this server instance
     */
    ErsatzServer feature(final ServerFeature feature) {
<span class="fc" id="L108">        features &lt;&lt; feature</span>
<span class="pc" id="L109">        this</span>
    }

    /**
     * Used to control the enabled/disabled state of HTTPS on the server. By default HTTPS is disabled.
     *
     * @param enabled whether or not HTTPS is enabled (defaults to true if omitted)
     * @return a reference to the server being configured
     */
    ErsatzServer enableHttps(boolean enabled = true) {
<span class="fc" id="L119">        httpsEnabled = enabled</span>
<span class="pc" id="L120">        this</span>
    }

    /**
     * Allows configuration of an external HTTPS keystore with the given location and password. By default, if this is not specified an internally
     * provided keystore will be used for HTTPS certification. See the User Guide for details about configuring your own keystore.
     *
     * @param location the URL of the keystore file
     * @param password the keystore file password (defaults to &quot;ersatz&quot; if omitted)
     * @return a reference to the server being configured
     */
    ServerConfig keystore(final URL location, final String password = 'ersatz') {
<span class="nc" id="L132">        keystoreLocation = location</span>
<span class="nc" id="L133">        keystorePass = password</span>
<span class="nc" id="L134">        this</span>
    }

    /**
     * Used to retrieve the port where the HTTP server is running.
     *
     * @deprecated Use getHttpPort() instead
     * @return the HTTP server port
     */
    @Deprecated
    int getPort() {
<span class="pc" id="L145">        actualHttpPort</span>
    }

    /**
     * Used to retrieve the port where the HTTP server is running.
     *
     * @return the HTTP port
     */
    int getHttpPort() {
<span class="nc" id="L154">        actualHttpPort</span>
    }

    /**
     * Used to retrieve the port where the HTTPS server is running.
     *
     * @return the HTTPS port
     */
    int getHttpsPort() {
<span class="nc" id="L163">        actualHttpsPort</span>
    }

    /**
     * Used to retrieve the full URL of the HTTP server.
     *
     * @deprecated Use getHttpUrl() instead
     * @return the full URL of the HTTP server
     */
    @Deprecated
    String getServerUrl() {
<span class="pc" id="L174">        &quot;http://localhost:$actualHttpPort&quot;</span>
    }

    /**
     * Used to retrieve the full URL of the HTTP server.
     *
     * @return the full URL of the HTTP server
     */
    String getHttpUrl() {
<span class="nc" id="L183">        &quot;http://localhost:$actualHttpPort&quot;</span>
    }

    /**
     * Used to retrieve the full URL of the HTTPS server.
     *
     * @return the full URL of the HTTP server
     */
    String getHttpsUrl() {
<span class="pc" id="L192">        &quot;https://localhost:$actualHttpsPort&quot;</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided &lt;code&gt;Consumer&lt;Expectations&gt;&lt;/code&gt; implementation will have an active
     * &lt;code&gt;Expectations&lt;/code&gt; object passed into it for configuring server interaction expectations.
     *
     * @param expects the &lt;code&gt;Consumer&lt;Expectations&gt;&lt;/code&gt; instance to perform the configuration
     * @return a reference to this server
     */
    @SuppressWarnings('ConfusingMethodName')
    ErsatzServer expectations(final Consumer&lt;Expectations&gt; expects) {
<span class="fc" id="L204">        expects.accept(expectations)</span>
<span class="pc" id="L205">        this</span>
    }

    /**
     * An alternate means of starting the expectation chain.
     *
     * @return the reference to the Expectation configuration object
     */
    Expectations expects() {
<span class="pc" id="L214">        expectations</span>
    }

    @Override
    ErsatzServer decoder(String contentType, BiFunction&lt;byte[], DecodingContext, Object&gt; decoder) {
<span class="nc" id="L219">        globalDecoders.register contentType, decoder</span>
<span class="nc" id="L220">        this</span>
    }

    @Override
    ErsatzServer decoder(ContentType contentType, BiFunction&lt;byte[], DecodingContext, Object&gt; decoder) {
<span class="nc" id="L225">        globalDecoders.register contentType, decoder</span>
<span class="nc" id="L226">        this</span>
    }

    @Override
    ServerConfig encoder(String contentType, Class objectType, Function&lt;Object, String&gt; encoder) {
<span class="nc" id="L231">        globalEncoders.register contentType, objectType, encoder</span>
<span class="nc" id="L232">        this</span>
    }

    @Override
    ServerConfig encoder(ContentType contentType, Class objectType, Function&lt;Object, String&gt; encoder) {
<span class="fc" id="L237">        globalEncoders.register contentType, objectType, encoder</span>
<span class="pc" id="L238">        this</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided Groovy &lt;code&gt;Closure&lt;/code&gt; will delegate to an &lt;code&gt;Expectations&lt;/code&gt;
     * instance for configuring server interaction expectations using the Groovy DSL.
     *
     * @param closure the Groovy &lt;code&gt;Closure&lt;/code&gt; which will provide expectation configuration via DSL
     * @return a reference to this server
     */
    @SuppressWarnings('ConfusingMethodName')
    ErsatzServer expectations(@DelegatesTo(Expectations) final Closure closure) {
<span class="fc" id="L250">        closure.delegate = expectations</span>
<span class="fc" id="L251">        closure.call()</span>
<span class="pc" id="L252">        this</span>
    }

    /**
     * Used to start the HTTP server for test interactions. This method should be called after configuration of expectations and before the test
     * interactions are executed against the server.
     */
    void start() {
<span class="fc" id="L260">        Undertow.Builder builder = Undertow.builder().addHttpListener(EPHEMERAL_PORT, LOCALHOST)</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (httpsEnabled) {</span>
<span class="fc" id="L263">            builder.addHttpsListener(EPHEMERAL_PORT, LOCALHOST, sslContext())</span>
        }

<span class="fc" id="L266">        server = builder.setHandler(new BlockingHandler(applyFeatures(new HttpHandler() {</span>
            @Override void handleRequest(final HttpServerExchange exchange) throws Exception {
<span class="fc" id="L268">                ClientRequest clientRequest = new UndertowClientRequest(exchange)</span>

<span class="fc" id="L270">                log.debug 'Request: {}', clientRequest</span>

<span class="fc" id="L272">                ErsatzRequest request = expectations.findMatch(clientRequest) as ErsatzRequest</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                if (request) {</span>
<span class="fc" id="L274">                    send(exchange, request.currentResponse)</span>
<span class="fc" id="L275">                    request.mark(clientRequest)</span>

                } else {
<span class="fc" id="L278">                    log.warn 'Unmatched-Request: {}', clientRequest</span>

<span class="fc" id="L280">                    exchange.setStatusCode(404).responseSender.send(NOT_FOUND_BODY)</span>
                }
            }
        }))).build()

<span class="fc" id="L285">        server.start()</span>

<span class="fc" id="L287">        actualHttpPort = (server.listenerInfo[0].address as InetSocketAddress).port</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (httpsEnabled) {</span>
<span class="fc" id="L290">            actualHttpsPort = (server.listenerInfo[1].address as InetSocketAddress).port</span>
        }
    }

    /**
     * Used to stop the HTTP server. The server may be restarted after it has been stopped.
     */
    void stop() {
<span class="fc" id="L298">        actualHttpPort = -1</span>
<span class="fc" id="L299">        actualHttpsPort = -1</span>

<span class="fc bfc" id="L301" title="All 2 branches covered.">        server?.stop()</span>
    }

    /**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back from
     * the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     */
    boolean verify() {
<span class="pc" id="L312">        expectations.verify()</span>
    }

    private HttpHandler applyFeatures(final HttpHandler handler) {
<span class="fc" id="L316">        HttpHandler result = handler</span>

<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        features?.each { feat -&gt;</span>
<span class="pc" id="L319">            result = feat.apply(result)</span>
        }

<span class="pc" id="L322">        result</span>
    }

    private static void send(final HttpServerExchange exchange, final Response response) {
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (response) {</span>
<span class="fc" id="L327">            exchange.statusCode = response.code</span>

<span class="fc" id="L329">            response.headers.each { k, v -&gt;</span>
<span class="pc" id="L330">                exchange.responseHeaders.put(new HttpString(k), v)</span>
            }

<span class="fc" id="L333">            response.cookies.each { k, v -&gt;</span>
<span class="pc" id="L334">                exchange.responseCookies.put(k, new CookieImpl(k, v))</span>
            }
        }

<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        String responseContent = response?.content</span>

<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        log.debug 'Response: {}', responseContent.take(1000)</span>

<span class="fc" id="L342">        exchange.responseSender.send(responseContent)</span>
    }

    @CompileStatic(TypeCheckingMode.SKIP)
    private SSLContext sslContext() {
<span class="fc" id="L347">        KeyStore keyStore = KeyStore.getInstance('JKS')</span>

<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        (keystoreLocation ?: ErsatzServer.getResource('/ersatz.keystore')).withInputStream { instr -&gt;</span>
<span class="pc" id="L350">            keyStore.load(instr, keystorePass.toCharArray())</span>
        }

<span class="fc" id="L353">        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.defaultAlgorithm)</span>
<span class="fc" id="L354">        keyManagerFactory.init(keyStore, keystorePass.toCharArray())</span>

<span class="fc" id="L356">        SSLContext sslContext = SSLContext.getInstance('TLS')</span>
<span class="fc" id="L357">        sslContext.init(keyManagerFactory.keyManagers, null, null)</span>

<span class="pc" id="L359">        sslContext</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>
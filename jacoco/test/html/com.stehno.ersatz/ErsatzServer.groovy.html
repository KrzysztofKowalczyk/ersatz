<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ErsatzServer.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ersatz</a> &gt; <a href="index.source.html" class="el_package">com.stehno.ersatz</a> &gt; <span class="el_source">ErsatzServer.groovy</span></div><h1>ErsatzServer.groovy</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Christopher J. Stehno
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.stehno.ersatz

import com.stehno.ersatz.impl.ErsatzRequest
import com.stehno.ersatz.impl.ExpectationsImpl
import groovy.transform.CompileStatic
import groovy.util.logging.Slf4j
import io.undertow.Undertow
import io.undertow.server.HttpHandler
import io.undertow.server.HttpServerExchange
import io.undertow.server.handlers.CookieImpl
import io.undertow.util.HttpString

import java.util.function.Consumer

/**
 * The main entry point for an Ersatz server, used to configure the expectations and manage the server itself. This is the class that should be
 * instantiated in unit tests.
 *
 * The server will be started on an ephemeral port so as not to collide with itself or other server applications running in the test environment. In
 * your tests, you can retrieve the server port or URL using the &lt;code&gt;getPort()&lt;/code&gt; and &lt;code&gt;getServerUrl()&lt;/code&gt; methods respectively.
 *
 * Using the &lt;code&gt;ErsatzServer&lt;/code&gt; follows the workflow:
 *
 * &lt;ol&gt;
 *     &lt;li&gt;Create the &lt;code&gt;ErsatzServer&lt;/code&gt; instance.&lt;/li&gt;
 *     &lt;li&gt;Configure the expectations.&lt;/li&gt;
 *     &lt;li&gt;Start the server&lt;/li&gt;
 *     &lt;li&gt;Run your client tests against the server.&lt;/li&gt;
 *     &lt;li&gt;Verify the expectations.&lt;/li&gt;
 *     &lt;li&gt;Stop the server.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * See the User Guide for more detailed information.
 */
@CompileStatic @Slf4j
class ErsatzServer {

    /**
     * The response body returned when no matching expectation could be found.
     */
    static final String NOT_FOUND_BODY = '404: Not Found'

    /**
     * The server feature extensions configured on the server.
     */
<span class="fc" id="L61">    List&lt;ServerFeature&gt; features = []</span>

<span class="fc" id="L63">    private final ExpectationsImpl expectations = new ExpectationsImpl()</span>
    private Undertow server
    private int actualPort = -1

    /**
     * Used to enable support for a feature extension.
     *
     * @param feature the &lt;code&gt;ServerFeature&lt;/code&gt; to be added
     */
    void addFeature(ServerFeature feature) {
<span class="nc" id="L73">        features &lt;&lt; feature</span>
    }

    /**
     * Used to retrieve the port where the HTTP server is running.
     *
     * @return the HTTP server port
     */
    int getPort() {
<span class="pc" id="L82">        actualPort</span>
    }

    /**
     * Used to retrieve the full URL of the HTTP server.
     *
     * @return the full URL of the HTTP server
     */
    String getServerUrl() {
<span class="pc" id="L91">        &quot;http://localhost:$actualPort&quot;</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided &lt;code&gt;Consumer&lt;Expectations&gt;&lt;/code&gt; implementation will have an active
     * &lt;code&gt;Expectations&lt;/code&gt; object passed into it for configuring server interaction expectations.
     *
     * @param expects the &lt;code&gt;Consumer&lt;Expectations&gt;&lt;/code&gt; instance to perform the configuration
     * @return a reference to this server
     */
    @SuppressWarnings('ConfusingMethodName')
    ErsatzServer expectations(final Consumer&lt;Expectations&gt; expects) {
<span class="fc" id="L103">        expects.accept(expectations)</span>
<span class="pc" id="L104">        this</span>
    }

    /**
     * An alternate means of starting the expectation chain.
     *
     * @return the reference to the Expectation configuration object
     */
    Expectations expects() {
<span class="nc" id="L113">        expectations</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided Groovy &lt;code&gt;Closure&lt;/code&gt; will delegate to an &lt;code&gt;Expectations&lt;/code&gt;
     * instance for configuring server interaction expectations using the Groovy DSL.
     *
     * @param closure the Groovy &lt;code&gt;Closure&lt;/code&gt; which will provide expectation configuration via DSL
     * @return a reference to this server
     */
    @SuppressWarnings('ConfusingMethodName')
    ErsatzServer expectations(@DelegatesTo(Expectations) final Closure closure) {
<span class="fc" id="L125">        closure.delegate = expectations</span>
<span class="fc" id="L126">        closure.call()</span>
<span class="pc" id="L127">        this</span>
    }

    /**
     * Used to start the HTTP server for test interactions. This method should be called after configuration of expectations and before the test
     * interactions are executed against the server.
     */
    void start() {
<span class="fc" id="L135">        server = Undertow.builder().addHttpListener(0, 'localhost').setHandler(applyFeatures(new HttpHandler() {</span>
            @Override
            void handleRequest(final HttpServerExchange exchange) throws Exception {
<span class="fc" id="L138">                ClientRequest clientRequest = new ClientRequest(exchange)</span>

<span class="fc" id="L140">                log.debug 'Request: {}', clientRequest</span>

<span class="fc" id="L142">                ErsatzRequest request = expectations.findMatch(clientRequest) as ErsatzRequest</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                if (request) {</span>
<span class="fc" id="L144">                    send(exchange, request.currentResponse)</span>
<span class="fc" id="L145">                    request.mark()</span>

                } else {
<span class="fc" id="L148">                    log.warn 'Unmatched-Request: {}', clientRequest</span>

<span class="fc" id="L150">                    exchange.setStatusCode(404).responseSender.send(NOT_FOUND_BODY)</span>
                }
            }
        })).build()

<span class="fc" id="L155">        server.start()</span>

<span class="fc" id="L157">        actualPort = (server.listenerInfo[0].address as InetSocketAddress).port</span>
    }

    /**
     * Used to stop the HTTP server.
     */
    void stop() {
<span class="fc" id="L164">        actualPort = -1</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">        server?.stop()</span>
    }

    /**
     * Used to verify all of the HTTP server interaction for their expected call criteria (if any). This method should be called after any test
     * interactions have been performed. This is an optional step since generally you will also be receiving the expected response back from the
     * server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     */
    boolean verify() {
<span class="pc" id="L177">        expectations.verify()</span>
    }

    private HttpHandler applyFeatures(final HttpHandler handler) {
<span class="fc" id="L181">        HttpHandler result = handler</span>

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        features?.each { feat -&gt;</span>
<span class="pc" id="L184">            result = feat.apply(result)</span>
        }

<span class="pc" id="L187">        result</span>
    }

    private static void send(final HttpServerExchange exchange, final Response response) {
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (response) {</span>
<span class="fc" id="L192">            exchange.statusCode = response.code</span>

<span class="fc" id="L194">            response.headers.each { k, v -&gt;</span>
<span class="pc" id="L195">                exchange.responseHeaders.put(new HttpString(k), v)</span>
            }

<span class="fc" id="L198">            response.cookies.each { k, v -&gt;</span>
<span class="pc" id="L199">                exchange.responseCookies.put(k, new CookieImpl(k, v))</span>
            }
        }

<span class="pc bpc" id="L203" title="1 of 6 branches missed.">        String responseContent = response?.content?.toString() ?: ''</span>

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        log.debug 'Response: {}', responseContent.take(1000)</span>

<span class="fc" id="L207">        exchange.responseSender.send(responseContent)</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>